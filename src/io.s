;*
;* JAVA I/O FOR 6502
;*
	.INCLUDE	"global.inc"
;*
;* HANDY ROM ROUTINES
;*
ROM_MONITOR	EQU	$FF65
ROM_HOME	EQU	$FC58
ROM_BELL	EQU	$FF3A
ROM_COUT	EQU	$FDED
ROM_CROUT	EQU	$FD8E
ROM_CROUT1	EQU	$FD8B
ROM_CLREOL	EQU	$FC9C
ROM_PRBLNK	EQU	$F948
ROM_PRBL2	EQU	$F94A
ROM_PRBYTE	EQU	$FDDA
ROM_PRNTAX	EQU	$F941
ROM_GETLN	EQU	$FD6A

	.IMPORT	HMEM_ALLOC,HMEM_LOCK,HMEM_ALLOC_FIXED,HMEM_FREE,HMEM_PTR
	.IMPORT	THREAD_YIELD,THREAD_NOTIMEOUT,THREAD_NOTIFYIO,THREAD_WAITIO,SYSTEM_TIC,CURRENT_THREAD
	.IMPORT	THROW_IOEXCPTN,THROW_INTERNALERR,THREAD_TRACE
	.IMPORT	WARM_INIT,MEMCPY
	.IMPORT	THREAD_SELECTIO,IO_NOTIFY,SLOT2MASK
	.EXPORT	IO_INIT,IODEV_INIT,VBL_INIT,HOME,GETLN,PRNTAX,CROUT,PRBYTE,COUT
	.EXPORT	PUTS
	.EXPORT	PUTSLN
	.EXPORT	PRSTR,PRSTRLN,PRHSTR,PRHSTRLN
	.EXPORT	KBWAIT
	.EXPORT	ON_LINE
	.EXPORT	PREFIX_GET,PREFIX_SET,DIR_CREATE,FILE_CREATE,FILE_DESTROY,FILE_GETEOF,FILE_GETINFO
	.EXPORT	FILE_OPEN,FILE_SETBUFFER,FILE_SETAUX,FILE_READ,FILE_WRITE,FILE_CLOSE,FILE_BLOAD

	.SEGMENT "INIT"
IO_INIT:	LDA	#$00
	STA	TYPEBUFFLEN
	STA	LCIN_MASK
	LDA	MACHID		; CHECK FOR II OR II+
	AND	#$88
	BEQ	:+
	LDA	#$20
:	EOR	#$DF		; LCOUT_MASK = $DF FOR II & II+, $FF FOR IIE & IIC
	STA	LCOUT_MASK
	LDX	#$0E
:	LDA	#<UNIMPL_DRVR		; FILL DRIVER TABLE WITH UNIMPLEMENTED DRIVER
	STA	LINK_DEVREAD,X
	STA	LINK_DEVWRITE,X
	STA	LINK_DEVCTRL,X
	LDA	#>UNIMPL_DRVR
	STA	LINK_DEVREAD+1,X
	STA	LINK_DEVWRITE+1,X
	STA	LINK_DEVCTRL+1,X
	DEX
	DEX
	BPL	:-
	BIT	ROMIN
	JSR	PRODOS
	.BYTE	$40		; ALLOC INTERRUPT
	.ADDR	ALLOCINTPARMS
.IFDEF	DEBUG	
	BCC	:+
	JSR	PUTSLN
	.ASCIIZ	"FAILED TO ALLOCATE INTERRUPT"
:
.ENDIF
	RTS
ALLOCINTPARMS:	.BYTE	$02
	.BYTE	$00		; INT NUM
	.ADDR	IO_INTERRUPT		; INT CODE
;*
;* IO DEVICE INIT
;*
IODEV_INIT:	PHP
	SEI			; TURN OFF INTERRUPTS
	LDA	#<SW_TIMER		; CREATE EXTERNAL LINKEAGE TO YIELD AT $300
	STA	LINK_YIELD
	LDA	#>SW_TIMER
	STA	LINK_YIELD+1
	LDA	#<PRODOS_MLI
	STA	LINK_PRODOS
	LDA	#>PRODOS_MLI
	STA	LINK_PRODOS+1
	LDA	#<PRHSTR
	STA	LINK_SCRPRT
	LDA	#>PRHSTR
	STA	LINK_SCRPRT+1
	LDA	#<PRHSTRLN
	STA	LINK_SCRPRTLN
	LDA	#>PRHSTRLN
	STA	LINK_SCRPRTLN+1
	LDA	#<KEYBD_POLL		; INSERT KEYBOARD POLL INTO POLLDEV LINKEAGE
	STA	LINK_DEVPOLL
	LDA	#>KEYBD_POLL
	STA	LINK_DEVPOLL+1
	LDA	#<THREAD_SELECTIO
	LDX	#>THREAD_SELECTIO
	STA	LINK_DEVWRITE
	STX	LINK_DEVWRITE+1
	LDA	#<CON_DRIVER		; LOAD CONSOLE DRIVER
	LDX	#>CON_DRIVER
	LDY	#$03		; IN SLOT 3
	JSR	LOAD_DRIVER
	LDA	#<COUT		; JUMP STRAIGHT TO COUT
	LDX	#>COUT
	STA	LINK_DEVWRITE+6
	STX	LINK_DEVWRITE+7
	LDA	WARM_INIT
	BNE	:+
	JSR	PUTS
	.ASCIIZ	"Console in slot #03"
	JSR	CROUT
:
.IFDEF	DEBUG_DUMP
	LDA	#DEBUG_DUMP+1		; START WITH SLOT FOLLOWING DEBUG DUMP
.ELSE
	LDA	#$01
.ENDIF
	LDX	#$31		; LOOK FOR SSC
	JSR	SCAN_SLOTS
	BCC	:+
	JMP	SRCHGT
:	STA	SSCSLOT
	TAY
	LDA	#<SSC_DRIVER		; LOAD SUPER SERIAL CARD DRIVER
	LDX	#>SSC_DRIVER
	JSR	LOAD_DRIVER
	LDY	SSCSLOT		; INIT SSC
	JSR	SSC_INIT
	LDA	SSCSLOT
	ASL	SSCSLOT
	STA	LOADSLOT
	LDA	WARM_INIT
	BNE	NEXTSSC
	JSR	PUTS
	.ASCIIZ	"SuperSerial in slot #"
	LDA	LOADSLOT
	JSR	PRBYTE
	JSR	CROUT
NEXTSSC:	INC	LOADSLOT
	LDA	LOADSLOT
	CMP	#$08
	BCS	SRCHGT
	LDX	#$31		; LOOK FOR MORE SSC
	JSR	SCAN_SLOTS
	BCS	SRCHGT
	STA	LOADSLOT
	ASL
	TAY
	LDX	SSCSLOT		; COPY DRIVER ENTRPOINTS TO ANOTHER SLOT
	LDA	LINK_DEVREAD,X
	STA	LINK_DEVREAD,Y
	LDA	LINK_DEVREAD+1,X
	STA	LINK_DEVREAD+1,Y
	LDA	LINK_DEVWRITE,X
	STA	LINK_DEVWRITE,Y
	LDA	LINK_DEVWRITE+1,X
	STA	LINK_DEVWRITE+1,Y
	LDA	LINK_DEVCTRL,X
	STA	LINK_DEVCTRL,Y
	LDA	LINK_DEVCTRL+1,X
	STA	LINK_DEVCTRL+1,Y
	LDA	LINK_DEVIRQ,X
	STA	LINK_DEVIRQ,Y
	LDA	LINK_DEVIRQ+1,X
	STA	LINK_DEVIRQ+1,Y
	LDA	WARM_INIT
	BNE	:+
	JSR	PUTS
	.ASCIIZ	"SuperSerial in slot #"
	LDA	LOADSLOT
	JSR	PRBYTE
	JSR	CROUT
:	JMP	NEXTSSC		; LOOK FOR ALL SSC
SRCHGT:	LDA	#$C1		; LOOK FOR GRAPHICS TABLET & UTHERNET CARD
	STA	TMPTR+1
	LDA	#$00
	STA	TMPTR
CHKGT:	LDY	#$01		; CHECK FOR GRAPHICS TABLET
	LDA	(TMPTR),Y
	CMP	#$B0
	BNE	NXTGT
	LDY	#$09
	LDA	(TMPTR),Y
	CMP	#$20
	BNE	NXTGT
	LDA	TMPTR+1
	AND	#$07
	PHA
	TAY
	LDA	#<GT_DRIVER		; LOAD GRAPHICS TABLET DRIVER
	LDX	#>GT_DRIVER
	JSR	LOAD_DRIVER
	LDA	WARM_INIT
	BNE	:+
	JSR	PUTS
	.ASCIIZ	"Graphics Tablet in slot #"
	PLA
	PHA
	JSR	PRBYTE
	JSR	CROUT
:	PLA
	JMP	CHKUTHR		; SKIP IF GRAPHICS TABLET FOUND
NXTGT:	INC	TMPTR+1
	LDA	TMPTR+1
	CMP	#$C8
	BCC	CHKGT
CHKUTHR:	JSR	UTHER_PROBE1
	BCS	:+
	LDA	#<UTHER_DRIVER1		; LOAD UTHERNET DRIVER
	LDX	#>UTHER_DRIVER1
	LDY	#$01
	BNE	LOADUTHR
:	JSR	UTHER_PROBE2
	BCS	:+	
	LDA	#<UTHER_DRIVER2		; LOAD UTHERNET DRIVER
	LDX	#>UTHER_DRIVER2
	LDY	#$02
	BNE	LOADUTHR
:	JSR	UTHER_PROBE4
	BCS	:+
	LDA	#<UTHER_DRIVER4		; LOAD UTHERNET DRIVER
	LDX	#>UTHER_DRIVER4
	LDY	#$04
	BNE	LOADUTHR
:	JSR	UTHER_PROBE5
	BCS	:+
	LDA	#<UTHER_DRIVER5		; LOAD UTHERNET DRIVER
	LDX	#>UTHER_DRIVER5
	LDY	#$05
	BNE	LOADUTHR
:	JSR	UTHER_PROBE6
	BCS	:+
	LDA	#<UTHER_DRIVER6		; LOAD UTHERNET DRIVER
	LDX	#>UTHER_DRIVER6
	LDY	#$06
	BNE	LOADUTHR
:	JSR	UTHER_PROBE7
	BCS	CHKMOUSE
	LDA	#<UTHER_DRIVER7		; LOAD UTHERNET DRIVER
	LDX	#>UTHER_DRIVER7
	LDY	#$07
LOADUTHR:	STY	UTHRSLOT
	JSR	LOAD_DRIVER
	LDA	DRVRADDR		; INSERT UTHER POLL INTO YIELD LINKEAGE
	STA	LINK_DEVPOLL
	LDA	DRVRADDR+1
	STA	LINK_DEVPOLL+1
	LDY	WARM_INIT
	BNE	CHKMOUSE
	JSR	PUTS
	.ASCIIZ	"Uthernet in slot #"
	LDA	UTHRSLOT
	JSR	PRBYTE
	JSR	CROUT
CHKMOUSE:	LDX	#$20		; LOOK FOR MOUSE
	LDA	#$01
	JSR	SCAN_SLOTS
	BCS	NOMOUSE
	PHA			; SAVE SLOT
	LDY	#$13
	LDA	(TMPTR),Y
	STA	SERVEMOUSE+1		; FIXUP IRQ HANDLER
	STX	SERVEMOUSE+2
	LDY	#$14
	LDA	(TMPTR),Y
	STA	READMOUSE+1		; FIXUP IRQ HANDLER
	STX	READMOUSE+2
	TXA
	AND	#$07
	STA	MOUSE_SLOT
	TAY
	JSR	MOUSE_INIT		; MAKE SURE MOUSE IS OFF, INTS OFF
	LDA	WARM_INIT
	BNE	:+
	JSR	PUTS
	.ASCIIZ	"Mouse in slot #"
	LDA	MOUSE_SLOT
	JSR	PRBYTE
	JSR	CROUT
:	PLA
	TAY
	LDA	#<MOUSE_DRIVER		; LOAD MOUSE DRIVER
	LDX	#>MOUSE_DRIVER
	JSR	LOAD_DRIVER
	LDA	#<THREAD_YIELD		; REMOVE SOFTWARE TIMER
	STA	LINK_YIELD
	LDA	#>THREAD_YIELD
	STA	LINK_YIELD+1
NOMOUSE:	PLP
	RTS
;
; SCAN SLOTS FOR MATCHING CARD ID
; ENTRY: A = START SLOT SCAN
;        X = CARD ID
; EXIT:  A = SLOT # :: C = 0
;        X = SLOT PAGE
;
SCAN_SLOTS:	ORA	#$C0
	STA	TMPTR+1
	LDA	#$00
	STA	TMPTR
CHKSIG:	LDY	#$05
	LDA	(TMPTR),Y
	CMP	#$38		; LOOK FOR PASCAL COMPAT SIG
	BNE	:+
	LDY	#$07
	LDA	(TMPTR),Y
	CMP	#$18
	BNE	:+
	LDY	#$0B
	LDA	(TMPTR),Y
	CMP	#$01
	BNE	:+
	LDY	#$0C
	TXA			; LOOK FOR MATCHING ID
	CMP	(TMPTR),Y
	BNE	:+
	LDA	TMPTR+1
	TAX
	AND	#$07
	CLC
	RTS
:	INC	TMPTR+1
	LDA	TMPTR+1
	CMP	#$C8
	BCC	CHKSIG
	SEC
	RTS
;
; LOAD DEVICE DRIVER AND INSERT INTO LINK TABLE
; ENTRY: AX = DRIVER ADDRESS
;         Y = SLOT #
;
LOAD_DRIVER:	STA	LDPTR		; DRIVER ENTRIES
	STX	LDPTR+1
	CLC
	ADC	#$0A		; START OF CODE
	STA	SRCADDR
	BCC	:+
	INX
:	STX	SRCADDR+1
	TYA
	ASL
	STA	LOADSLOT
	LDY	#$01		; GET DRIVER SIZE
	LDA	(LDPTR),Y
	DEY
	TAX
	LDA	(LDPTR),Y
	INY
	JSR	HMEM_ALLOC		; ALLOC THE MEMORY
	JSR	HMEM_LOCK		; AND LOCK IT - FOREVER
	STA	DSTADDR
	STA	DRVRADDR
	STX	DSTADDR+1
	STX	DRVRADDR+1
	LDX	LOADSLOT
	LDY	#$02		; INSERT DEVICE READ ROUTINE
	CLC
	ADC	(LDPTR),Y
	INY
	STA	LINK_DEVREAD,X
	LDA	DSTADDR+1
	ADC	(LDPTR),Y
	INY
	STA	LINK_DEVREAD+1,X
	LDA	DSTADDR		; INSERT DEVICE WRITE ROUTINE
	CLC
	ADC	(LDPTR),Y
	INY
	STA	LINK_DEVWRITE,X
	LDA	DSTADDR+1
	ADC	(LDPTR),Y
	INY
	STA	LINK_DEVWRITE+1,X
	LDA	DSTADDR		; INSERT DEVICE CTRL ROUTINE
	CLC
	ADC	(LDPTR),Y
	INY
	STA	LINK_DEVCTRL,X
	LDA	DSTADDR+1
	ADC	(LDPTR),Y
	INY
	STA	LINK_DEVCTRL+1,X
	LDA	DSTADDR		; INSERT DEVICE IRQ ROUTINE
	CLC
	ADC	(LDPTR),Y
	INY
	STA	LINK_DEVIRQ,X
	LDA	DSTADDR+1
	ADC	(LDPTR),Y
	STA	LINK_DEVIRQ+1,X
	LDY	#$01		; GET DRIVER SIZE
	LDA	(LDPTR),Y
	DEY
	TAX
	LDA	(LDPTR),Y
	JMP	MEMCPY		; MOVE DRIVER TO LOCKED MEM AND DONE	
LOADSLOT:	.BYTE	$00
SSCSLOT:	.BYTE	$00
UTHRSLOT:	.BYTE	$00
MOUSE_SLOT:	.BYTE	$00
DRVRADDR:	.WORD	$0000
	.INCLUDE	"consoledrvr.s"
	.INCLUDE	"sscdrvr.s"
	.INCLUDE	"mousedrvr.s"
	.INCLUDE	"graphtabdrvr.s"
UTHERSLOT1	= 1
	.INCLUDE	"utherdrvr.s"
UTHERSLOT2	= 1
	.INCLUDE	"utherdrvr.s"
UTHERSLOT4	= 1
	.INCLUDE	"utherdrvr.s"
UTHERSLOT5	= 1
	.INCLUDE	"utherdrvr.s"
UTHERSLOT6	= 1
	.INCLUDE	"utherdrvr.s"
UTHERSLOT7	= 1
	.INCLUDE	"utherdrvr.s"
;*
;* TURN VBL INTS ON AFTER INIT
;*
VBL_INIT:	LDA	MOUSE_SLOT
	BEQ	NOVBL
	ASL
	TAX
	LSR
	ORA	#MOUSECTL_CALLFW
	TAY
	SEI			; TURN OFF INTERRUPTS
	LDA	LINK_DEVCTRL,X
	STA	CALLVBLPROC+1
	LDA	LINK_DEVCTRL+1,X
	STA	CALLVBLPROC+2
	LDA	#$08		; TURN MOUSE OFF, LEAVE VBL ON
	LDX	#$12
CALLVBLPROC:	JSR	$0000
	CLI			; BACK ON
	LDA	WARM_INIT
	BNE	NOVBL
	JSR	PUTSLN
	.ASCIIZ	"VBlank timer active"
NOVBL:	RTS
;
; CREATE DIRECTORY - ONLY NEEDED DURING INIT
; ENTRY: AX = POINTER TO DIRECTORY PATHNAME
; EXIT:   C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
DIR_CREATE:	STA	CREATEPARMS+1
	STX	CREATEPARMS+2
	LDA	#$0F 		; DIRECTORY
	STA	CREATEPARMS+4
	LDA	#$0D		; SUBDIRECTORY
	STA	CREATEPARMS+7
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$C0		; CREATE FILE
	.ADDR	CREATEPARMS
	LDY	#$01
	STY	CREATEPARMS+7		; SET BACK TO NORMAL FILE
	JMP	SETLCBNK2
;
; VOLUMES ON LINE - ONLY NEEDED DURING INIT
; ENTRY: AX = POINTER TO 256 BYTE DATA BUFFER
;         Y = UNIT NUM
; EXIT:   C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
ON_LINE:	STA	VOLPARMS+2
	STX	VOLPARMS+3
	STY	VOLPARMS+1
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$C5
	.ADDR	VOLPARMS
	JMP	SETLCBNK2
;*
;* WRAPPERS FOR ROM ROUTINES
;*
GETLN:	BIT	ROMIN
	JSR	ROM_GETLN		; CALL GETLN
	JMP	SETLCBNK2
	
	.CODE

HOME:	BIT	ROMIN
	JSR	ROM_HOME
	JMP	SETLCBNK2
PRNTAX:	BIT	ROMIN
	JSR	ROM_PRNTAX
	JMP	SETLCBNK2
PRBYTE:	BIT	ROMIN
	JSR	ROM_PRBYTE
	JMP	SETLCBNK2
CROUT:	LDA	#$0D
COUT:	CMP	#$60		; LOWERCASE CHARACTER?
	BCC	:+
	AND	LCOUT_MASK		; APPLY LOWER->UPPER CONVERSION
:	ORA	#$80
	BIT	ROMIN
	JSR	ROM_COUT
SETLCBNK2:	SEI			; THIS CANNOT BE INTERRUPTED
	BIT	LCBNK2
	BIT	LCBNK2
	CLI
	RTS
;
; PRINT ASCIIZ STRING FOLLOWING JSR PUTS
;
PUTSLN:	LDX	#$0D
	BNE	:+
PUTS:	LDX	#$00
:	PLA
	STA	TMP
	PLA
	STA	TMP+1
	LDY	#$00
PUTS_LP:	INC	TMP
	BNE	:+
	INC	TMP+1
:	LDA	(TMP),Y
	BEQ	PUTS_EXIT
	JSR	COUT
	JMP	PUTS_LP
PUTS_EXIT:	TXA
	BEQ	:+
	JSR	COUT
:	LDA	TMP+1
	PHA
	LDA	TMP
	PHA
:	RTS
;
; PRINT STRING IN AX
;
PRHSTR:	CPX	#$00
	BEQ	:-
	JSR	HMEM_PTR
PRSTR:	STA	TMP
	STX	TMP+1
	LDY	#$00
	LDA	(TMP),Y
	BEQ	:-
	TAX
	INY
	BIT	ROMIN
PRSTR_LP:	LDA	(TMP),Y
	CMP	#$60		; LOWERCASE CHARACTER?
	BCC	:+
	AND	LCOUT_MASK		; APPLY LOWER->UPPER CONVERSION
:	ORA	#$80
	JSR	ROM_COUT
	INY
	DEX
	BNE	PRSTR_LP
	JMP	SETLCBNK2
PRHSTRLN:	CPX	#$00
	BEQ	:+
	JSR	HMEM_PTR
PRSTRLN:	JSR	PRSTR
:	BIT	ROMIN
	JSR	ROM_CLREOL
	JSR	CROUT
	RTS
;
; WAIT FOR KEYPRESS
;
KBWAIT:	LDA	KEYBD
	BPL	KBWAIT
	BIT	CLRKBD
	RTS
;*
;* I/O INTERRUPT ROUTINE
;*
IO_INTERRUPT:	CLD
	LDY	#$02		; SLOT #1 * 2
FNDIRQPROC:	LDA	LINK_DEVIRQ+1,Y
	BEQ	NXTIRQPROC
	STA	CALLIRQPROC+2
	LDA	LINK_DEVIRQ,Y
	STA	CALLIRQPROC+1
	TYA
	LSR
	PHA
CALLIRQPROC:	JSR	$0000
	BCS	:+
	PLA
	TAY
	PHA
	JSR	THREAD_NOTIFYIO
:	PLA
	ASL
	TAY
NXTIRQPROC:	INY
	INY
	CPY	#$10
	BCC	FNDIRQPROC
	CLC
	RTS
;
; UNIMPLEMENTED DRIVER PROC
;
UNIMPL_DRVR:	SEC
	RTS
;
; SOFTWARE IMPLEMENTED (FAKED) INTERRUPT ROUTINES
;
SW_TIMER:	LDA	OPCNT
	BEQ	:+
	CLC
	ADC	TIMERADJUST
	STA	TIMERADJUST
	BCC	:++
:	LDX	#$00
	LDA	#$60
	JSR	SYSTEM_TIC		; INCREMENT SYSTEM TICS BASED ON OPCNT
:	JMP	(LINK_DEVPOLL)		; JUMP TO IODEV_POLL
KEYBD_POLL:	LDA	KEYBD		; CHECK FOR PENDING KEYPRESS
	BMI	FAKE_IRQ
	JMP	THREAD_YIELD
FAKE_IRQ:	PHP			; SAVE FLAGS
	SEI			; MAKE SURE NO REAL INTERRUPTS HAPPEN
	LDX	#$06		; SAVE AND RESTORE ZP LIKE PRODOS
:	LDA	$F9,X
	STA	SAVEZPIRQ,X
	DEX
	BPL	:-
	JSR	IO_INTERRUPT
	LDX	#$06
:	LDA	SAVEZPIRQ,X
	STA	$F9,X
	DEX
	BPL	:-
	PLP			; RESTORE FLAGS
	JMP	THREAD_YIELD
;*
;* PRODOS WRAPPERS
;*
;
; CALL PRODOS MLI
; ENTRY: AX = BYTE ARRAY REFERENCE FOR PARAM BLOCK
;         Y = PRODOS COMMAND
PRODOS_MLI:	STY	MLI_CMD
	JSR	HMEM_PTR
	CLC			; SKIP ARRAY LENGTH WORD
	ADC	#$02
	BCC	:+
	INX
:	STA	MLI_PARAMS
	STX	MLI_PARAMS+1
	BIT	LCBNK1
	JSR	PRODOS
MLI_CMD:	.BYTE	$00
MLI_PARAMS:	.ADDR	$0000
	JMP	SETLCBNK2
;
; GET PREFIX
; ENTRY: AX = POINTER TO PREFIX STRING
; EXIT:   C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
PREFIX_GET:	LDY	#$C7
	BNE	PREFIX_OP
;
; SET PREFIX
; ENTRY: AX = POINTER TO PREFIX STRING
; EXIT:   C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
PREFIX_SET:	LDY	#$C6
	BNE	PREFIX_OP
;
; DESTROY FILE
; ENTRY: AX = POINTER TO FILE PATHNAME
; EXIT:   C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
FILE_DESTROY:	LDY	#$C1
PREFIX_OP:	STY	PREFIXCMD
	STA	PREFIXPARMS+1
	STX	PREFIXPARMS+2
	BIT	LCBNK1
	JSR	PRODOS
PREFIXCMD:	.BYTE	$C1
	.ADDR	PREFIXPARMS
	JMP	SETLCBNK2
;
; CREATE FILE
; ENTRY: AX = POINTER TO FILE PATHNAME
;         Y = FILE TYPE
; EXIT:   C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
FILE_SETAUX: 	STA	CREATEPARMS+5
	STX	CREATEPARMS+6
	RTS
FILE_CREATE:	STA	CREATEPARMS+1
	STX	CREATEPARMS+2
	TYA
	AND	#$07
	ORA	#$F0		; USER DEFINED TYPES $F1-$F8
	STA	CREATEPARMS+4
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$C0		; CREATE FILE
	.ADDR	CREATEPARMS
	JMP	SETLCBNK2
;
; GET FILE INFO
; ENTRY: AX = POINTER TO FILENAME
; EXIT:  AX = POINTER TO ATTRIBUTE BUFFER
;         C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
FILE_GETINFO:	STA	INFOPARMS+1
	STX	INFOPARMS+2
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$C4		; FILE GET INFO
	.ADDR	INFOPARMS
	BCS	:+
	LDA	#<INFOPARMS
	LDX	#>INFOPARMS
:	JMP	SETLCBNK2
;
; OPEN FILE
; ENTRY: AX = POINTER TO FILENAME
;         Y = HIGH ADDESS OF SYSTEM IO BUFFER
; EXIT:   Y = REF NUM
;         C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
FILE_OPEN:	STA	OPENPARMS+1
	STX	OPENPARMS+2
	STY	OPENPARMS+4
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$C8		; OPEN FILE
	.ADDR	OPENPARMS
	BCS	:+
	LDY	OPENPARMS+5
:	JMP	SETLCBNK2
;
; CLOSE FILE
; ENTRY: Y = REF NUM
;
FILE_CLOSE:	STY	CLOSEPARMS+1
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$CC		; CLOSE FILE
	.ADDR	CLOSEPARMS
	JMP	SETLCBNK2
; GET END-OF-FILE
; ENTRY:   Y = REF NUM
; EXIT:  AXY = EOF
;         C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
FILE_GETEOF:	STY	GETEOFPARMS+1
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$D1		; GET EOF (FILE LEN)
	.ADDR	GETEOFPARMS
	BCS	:+
	LDA	GETEOFPARMS+2
	LDX	GETEOFPARMS+3
	LDY	GETEOFPARMS+4
:	JMP	SETLCBNK2
;
; SET DATA BUFFER FOR READ/WRITE
; ENTRY: AX = ADDRESS OF BUFFER
;
FILE_SETBUFFER:	STA	WRITEPARMS+2
	STX	WRITEPARMS+3
	CLC
	RTS
;
; READ FROM FILE
; ENTRY: AX = NUMBER OF BYTES TO READ
;         Y = REF NUM
; EXIT:  AX = NUMBER OF BYTES ACTUALLY READ
;         C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
FILE_READ:	STA	READPARMS+4
	STX	READPARMS+5
	STY	READPARMS+1
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$CA		; READ FILE
	.ADDR	READPARMS
	BCS	:+
	LDA	READPARMS+6
	LDX	READPARMS+7
:	JMP	SETLCBNK2
;
; WRITE TO FILE
; ENTRY: AX = NUMBER OF BYTES TO WRITE
;         Y = REF NUM
; EXIT:  AX = NUMBER OF BYTES ACTUALLY WRITTEN
;         C = 0 :: SUCCESS
;         C = 1 :: FAILURE
;
FILE_WRITE:	STA	WRITEPARMS+4
	STX	WRITEPARMS+5
	STY	WRITEPARMS+1
	BIT	LCBNK1
	JSR	PRODOS
	.BYTE	$CB		; WRITE FILE
	.ADDR	WRITEPARMS
	BCS	:+
	LDA	WRITEPARMS+6
	LDX	WRITEPARMS+7
:	JMP	SETLCBNK2
;
; READ BINARY FILE
; ENTRY: AX = POINTER TO FILE NAME
;
FILE_BLOAD:	LDY	#>CLASSFILE_IO_BUFF
	JSR	FILE_OPEN
	JSR	FILE_GETEOF
	LDY	OPENPARMS+5
	JSR	FILE_READ
	LDY	OPENPARMS+5
	JMP	FILE_CLOSE

	.DATA
	
TIMERADJUST:	;.BYTE	$03		; OVERLAP WITH SLOT2IO
SLOT2IO:	.BYTE	$03,$10,$20,$30,$40,$50,$60,$70

CLOSEPARMS:	;.BYTE	$01
	;.BYTE	$00		; REF NUM
PREFIXPARMS:	.BYTE	$01
	.ADDR	$0000		; PATH ADDR
CREATEPARMS:	.BYTE	$07
	.WORD	$0000		; PATH ADDR
	.BYTE	$C3		; ACCESS BITS (FULL ACCESS)
	.BYTE	$00		; FILE TYPE
	.WORD	$0000		; AUX TYPE
	.BYTE	$01		; STORAGE TYPE
	.WORD	$0000		; CREATE DATE
	.WORD	$0000		; CREATE TIME
OPENPARMS:	.BYTE	$03
	.ADDR	$0000		; PATH ADDR
	.ADDR	$0000		; SYS BUFF ADDR
	.BYTE	$00		; REF NUM
VOLPARMS:	;.BYTE	$02
	;.BYTE	$00		; UNIT NUM
	;.ADDR	$0000		; DATA BUFFER ADDR
GETEOFPARMS:	.BYTE	$02
	.BYTE	$00		; REF NUM
	.BYTE	$00,$00,$00		; EOF L/M/H
READPARMS:	
WRITEPARMS:	.BYTE	$04
	.BYTE	$00		; REF NUM
	.ADDR	$0000		; DATA ADDR
	.ADDR	$0000		; DATA LEN
	.ADDR	$0000		; ACTUAL LEN
INFOPARMS:	.BYTE	$0A
	.WORD	$0000		; PATH ADDR
	.BYTE	$00		; ACCESS BITS
	.BYTE	$00		; FILE TYPE
	.WORD	$0000		; AUX TYPE
	.BYTE	$00		; STORAGE TYPE
	.WORD	$0000		; BLOCKS USED
	.WORD	$0000		; DATE OF LAST MOD
	.WORD	$0000		; TIME OF LAST MOD
	.WORD	$0000		; CREATE DATE
	.WORD	$0000		; CREATE TIME