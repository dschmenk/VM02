;* FROM GLOBAL.INC:
SRCADDR	=	$DC
DSTADDR	=	$DE
;*
;* CLASS FILE vm02.class
;*
	.ORG	$1000	; DUMMY ADDRESS
	.BYTE	$CA,$FE,$BA,$BE	; MAGIC
	.BYTE	$00,$00	; MINOR 0
	.BYTE	$00,$31	; MAJOR 49
;*
;* CONSTANT POOL
;*
	.BYTE	$00,31	; CONST POOL COUNT 31
;* CONST POOL INDEX 1
	.BYTE	$0A	; METHODREF
	.BYTE	$00,$03	; CLASS #3
	.BYTE	$00,$18	; NAME AND TYPE #24
;* CONST POOL INDEX 2
	.BYTE	07	; CLASS
	.BYTE	$00,$19	; #25
;* CONST POOL INDEX 3
	.BYTE	07	; CLASS
	.BYTE	$00,$1A	; #26
;* CONST POOL INDEX 4
	.BYTE	$01	; UTF8
	.BYTE	$00,$06	; STRLEN
	.BYTE	"<init>"
;* CONST POOL INDEX 5
	.BYTE	$01	; UTF8
	.BYTE	$00,$03	; STRLEN
	.BYTE	"()V"
;* CONST POOL INDEX 6
	.BYTE	$01	; UTF8
	.BYTE	$00,$04	; STRLEN
	.BYTE	"Code"
;* CONST POOL INDEX 7
	.BYTE	$01	; UTF8
	.BYTE	$00,$08	; STRLEN
	.BYTE	"pokeByte"
;* CONST POOL INDEX 8
	.BYTE	$01	; UTF8
	.BYTE	$00,$05	; STRLEN
	.BYTE	"(IB)V"
;* CONST POOL INDEX 9
	.BYTE	$01	; UTF8
	.BYTE	$00,$08	; STRLEN
	.BYTE	"pokeWord"
;* CONST POOL INDEX 10
	.BYTE	$01	; UTF8
	.BYTE	$00,$05	; STRLEN
	.BYTE	"(IS)V"
;* CONST POOL INDEX 11
	.BYTE	$01	; UTF8
	.BYTE	$00,$08	; STRLEN
	.BYTE	"peekByte"
;* CONST POOL INDEX 12
	.BYTE	$01	; UTF8
	.BYTE	$00,$04	; STRLEN
	.BYTE	"(I)I"
;* CONST POOL INDEX 13
	.BYTE	$01	; UTF8
	.BYTE	$00,$08	; STRLEN
	.BYTE	"peekWord"
;* CONST POOL INDEX 14
	.BYTE	$01	; UTF8
	.BYTE	$00,$04	; STRLEN
	.BYTE	"call"
;* CONST POOL INDEX 15
	.BYTE	$01	; UTF8
	.BYTE	$00,$05	; STRLEN
	.BYTE	"(II)I"
;* CONST POOL INDEX 16
	.BYTE	$01	; UTF8
	.BYTE	$00,$0B	; STRLEN
	.BYTE	"floatAsBits"
;* CONST POOL INDEX 17
	.BYTE	$01	; UTF8
	.BYTE	$00,$04	; STRLEN
	.BYTE	"(F)I"
;* CONST POOL INDEX 18
	.BYTE	$01	; UTF8
	.BYTE	$00,$0B	; STRLEN
	.BYTE	"bitsAsFloat"
;* CONST POOL INDEX 19
	.BYTE	$01	; UTF8
	.BYTE	$00,$04	; STRLEN
	.BYTE	"(I)F"
;* CONST POOL INDEX 20
	.BYTE	$01	; UTF8
	.BYTE	$00,$09	; STRLEN
	.BYTE	"refAsBits"
;* CONST POOL INDEX 21
	.BYTE	$01	; UTF8
	.BYTE	$00,$15	; STRLEN
	.BYTE	"(Ljava/lang/Object;)I"
;* CONST POOL INDEX 22
	.BYTE	$01	; UTF8
	.BYTE	$00,$09	; STRLEN
	.BYTE	"bitsAsRef"
;* CONST POOL INDEX 23
	.BYTE	$01	; UTF8
	.BYTE	$00,$15	; STRLEN
	.BYTE	"(I)Ljava/lang/Object;"
;* CONST POOL INDEX 24
	.BYTE	$0C	; NAME AND TYPE
	.BYTE	$00,$04	; NAME #4
	.BYTE	$00,$05	; DESC #5
;* CONST POOL INDEX 25
	.BYTE	$01	; UTF8
	.BYTE	$00,$0B	; STRLEN
	.BYTE	"apple2/vm02"
;* CONST POOL INDEX 26
	.BYTE	$01	; UTF8
	.BYTE	$00,$10	; STRLEN
	.BYTE	"java/lang/Object"
;* CONST POOL INDEX 27
	.BYTE	$01	; UTF8
	.BYTE	$00,$04	; STRLEN
	.BYTE	"6502"
;* CONST POOL INDEX 28
	.BYTE	$01	; UTF8
	.BYTE	$00,$09	; STRLEN
	.BYTE	"pokeBytes"
;* CONST POOL INDEX 29
	.BYTE	$01	; UTF8
	.BYTE	$00,$08	; STRLEN
	.BYTE	"(I[BII)V"
;* CONST POOL INDEX 30
	.BYTE	$01	; UTF8
	.BYTE	$00,$09	; STRLEN
	.BYTE	"peekBytes"
;*
;* ACCESS FLAGS
;*
	.BYTE	$00,$21	; 0x0021
;*
;* THIS CLASS
;*
	.BYTE	$00,$02	; #2
;*
;* SUPER CLASS
;*
	.BYTE	$00,$03	; #3
;*
;* INTERFACES
;*
	.BYTE	$00,$00	; IFACE COUNT 0
;*
;* FIELDS
;*
	.BYTE	$00,$00	; FIELD COUNT 0
;*
;* METHODS
;*
	.BYTE	$00,$0C	; METHOD COUNT 12
;******* METHOD INDEX 0 - <init> ********
	.BYTE	$00,$01	; ACCESS FLAGS 0x0001
	.BYTE	$00,$04	; NAME #4
	.BYTE	$00,$05	; DESC #5
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,$06	; NAME #6
	.BYTE	$00,$00,>(M0A0END-M0A0BGN),<(M0A0END-M0A0BGN)
M0A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$01	; MAX LOCALS 1
	.BYTE	$00,$00,>(M0C0END-M0C0BGN),<(M0C0END-M0C0BGN)
M0C0BGN:
	.BYTE	$2A	; 00000: aload_0
	.BYTE	$B7,$00,$01	; 00001: invokespecial #1
	.BYTE	$B1	; 00004: return
M0C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M0A0END:
;******* METHOD INDEX 1 - pokeByte ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$07	; NAME #7
	.BYTE	$00,$08	; DESC #8
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M1A0END-M1A0BGN),<(M1A0END-M1A0BGN)
M1A0BGN:
;* CODE:
	.BYTE	$00,$00	; MAX STACK 0
	.BYTE	$00,$02	; MAX LOCALS 2
	.BYTE	$00,$00,>(M1C0END-M1C0BGN),<(M1C0END-M1C0BGN)
M1C0BGN:
	PLA		; SAVE RETURN ADDRESS
	STA	$A4
	PLA
	STA	$A5
	PLA		; PULL POKE DATA
	STA	$A6
	PLA
	PLA
	PLA
	PLA		; PULL POKE ADDRESS
	STA	$A8
	PLA
	STA	$A9
	PLA
	PLA
	SEI
	BIT	$C081	; SELECT ROM
	LDY	#$00
	LDA	$A6
	STA	($A8),Y
	LDA	$A5
	PHA
	LDA	$A4
	PHA
	RTS
M1C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M1A0END:
;******* METHOD INDEX 2 - pokeWord ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$09	; NAME #9
	.BYTE	$00,$0A	; DESC #10
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M2A0END-M2A0BGN),<(M2A0END-M2A0BGN)
M2A0BGN:
;* CODE:
	.BYTE	$00,$00	; MAX STACK 0
	.BYTE	$00,$02	; MAX LOCALS 2
	.BYTE	$00,$00,>(M2C0END-M2C0BGN),<(M2C0END-M2C0BGN)
M2C0BGN:
	PLA		; SAVE RETURN ADDRESS
	STA	$A4
	PLA
	STA	$A5
	PLA		; PULL POKE DATA
	STA	$A6
	PLA
	STA	$A7
	PLA
	PLA
	PLA		; PULL POKE ADDRESS
	STA	$A8
	PLA
	STA	$A9
	PLA
	PLA
	SEI
	BIT	$C081	; SELECT ROM
	LDY	#$00
	LDA	$A6
	STA	($A8),Y
	INY
	LDA	$A7
	STA	($A8),Y
	LDA	$A5
	PHA
	LDA	$A4
	PHA
	RTS
M2C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M2A0END:
;******* METHOD INDEX 3 - peekByte ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$0B	; NAME #11
	.BYTE	$00,$0C	; DESC #12
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M3A0END-M3A0BGN),<(M3A0END-M3A0BGN)
M3A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$01	; MAX LOCALS 1
	.BYTE	$00,$00,>(M3C0END-M3C0BGN),<(M3C0END-M3C0BGN)
M3C0BGN:
	PLA		; SAVE RETURN ADDRESS
	STA	$A4
	PLA
	STA	$A5
	PLA		; PULL PEEK ADDRESS
	STA	$A6
	PLA
	STA	$A7
	PLA
	PLA
	SEI
	BIT	$C081	; SELECT ROM
	LDA	#$00	; PUSH HIWORD = 0
	PHA
	PHA
	PHA		; PUSH HIBYTE = 0
	TAY
	LDA	($A6),Y
	PHA
	LDA	$A5
	PHA
	LDA	$A4
	PHA
	RTS
M3C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M3A0END:
;******* METHOD INDEX 4 - peekWord ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$0D	; NAME #13
	.BYTE	$00,$0C	; DESC #12
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M4A0END-M4A0BGN),<(M4A0END-M4A0BGN)
M4A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$01	; MAX LOCALS 1
	.BYTE	$00,$00,>(M4C0END-M4C0BGN),<(M4C0END-M4C0BGN)
M4C0BGN:
	PLA		; SAVE RETURN ADDRESS
	STA	$A4
	PLA
	STA	$A5
	PLA		; PULL PEEK ADDRESS
	STA	$A6
	PLA
	STA	$A7
	PLA
	PLA
	SEI
	BIT	$C081	; SELECT ROM
	LDA	#$00	; PUSH HIWORD = 0
	PHA
	PHA
	LDY	#$01
	LDA	($A6),Y
	DEY
	PHA
	LDA	($A6),Y
	PHA
	LDA	$A5
	PHA
	LDA	$A4
	PHA
	RTS
M4C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M4A0END:
;******* METHOD INDEX 5 - call ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$0E	; NAME #14
	.BYTE	$00,$0F	; DESC #15
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M5A0END-M5A0BGN),<(M5A0END-M5A0BGN)
M5A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$02	; MAX LOCALS 2
	.BYTE	$00,$00,>(M5C0END-M5C0BGN),<(M5C0END-M5C0BGN)
M5C0BGN:
.IF	1
	JMP	($0390)	; NATIVE_CALL
.ELSE
	BCC	:+
M5C0LCKCNT:	.BYTE	$00	; LOCK/UNLOCK COUNT
:	PLA		; PULL RETURN ADDRESS
	STA	$A4
	PLA
	STA	$A5
	PLA		; PULL CALL ADDRESS
	STA	$A6
	PLA
	STA	$A7
	PLA
	PLA
	TSX
	LDA	$0101,X	; GET REG VALS
	STA	$A8	; BUT LEAVE ON STACK FOR RETUN VALS
	LDA	$0102,X
	STA	$A9
	LDA	$0103,X
	STA	$AA
	LDA	$A5	; PUSH RETURN ADDRESS
	PHA
	LDA	$A4
	PHA
	LDA	$A7
	BNE	M5C0ROMCALL
	LDY	$A6	; CONVERT SYSCALL INTO ADDRESS
	LDA	$0300,Y
	STA	$A6
	LDA	$0301,Y
	STA	$A7
	LDY	#$02
	LDA	($A0),Y	 ; INCREMENT LOCK COUNT
	CLC
	ADC	#$01
	STA	($A0),Y
	CMP	#$01
	BNE	M5C0SYSCALL	; SKIP LOCK IF ALREADY LOCKED
	LDA	#<(M5C0SYSCALL-M5C0BGN-1)
	CLC
	ADC	$A0
	TAX
	LDA	#>(M5C0SYSCALL-M5C0BGN-1)
	ADC	$A1
	PHA
	TXA
	PHA
	LDA	$A2
	LDX	$A3
	JMP	($30E)	; LOCK IT
M5C0ROMCALL:	BIT	$C081	; SELECT ROM
	LDA	#<(M5C0RET-M5C0BGN-1)
	CLC
	ADC	$A0
	TAX
	LDA	#>(M5C0RET-M5C0BGN-1)
	ADC	$A1
	PHA
	TXA
	PHA
	LDA	$A8
	LDX	$A9
	LDY	$AA
	JMP	($A6)
M5C0RET:	PHP
	STA	$A8
	STX	$A9
	PLA
	TSX
	STA	$0106,X
	TYA
	STA	$0105,X
	LDA	$A9
	STA	$0104,X
	LDA	$A8
	STA	$0103,X
	RTS
M5C0SYSCALL:	LDA	$A2	; SAVE MEMORY HANDLE FOR METHOD
	PHA
	LDA	$A3
	PHA
	LDA	$A0	; SAVE MEMORY ADDRESS FOR METHOD
	PHA
	LDA	$A1
	PHA
	LDA	#<(M5C0SYSRET-M5C0BGN-1)
	CLC
	ADC	$A0
	TAX
	LDA	#>(M5C0SYSRET-M5C0BGN-1)
	ADC	$A1
	PHA
	TXA
	PHA
	LDA	$A8
	LDX	$A9
	LDY	$AA
	JMP	($A6)	; CALL SYSTEM FUNC	
M5C0SYSRET:	PHP		; SAVE REGISTERS IN STACK PARAM
	STA	$A8
	STX	$A9
	PLA
	TSX
	STA	$010A,X
	TYA
	STA	$0109,X
	LDA	$A9
	STA	$0108,X
	LDA	$A8
	STA	$0107,X
	PLA		; RESTORE METHOD ADDRESS
	STA	$A1
	PLA
	STA	$A0
	LDY	#$02
	LDA	($A0),Y	 ; DECREMENT LOCK COUNT
	SEC
	SBC	#$01
	STA	($A0),Y
	BNE	:+	; SKIP UNLOCK IF COUNT > 0
	PLA		; RETRIEVE SAVED HANDLE
	TAX
	PLA
	JMP	($310)	; UNLOCK METHOD, RETURN TO CALLER
:	PLA		; DISCARD SAVED HANDLE
	PLA
	RTS
.ENDIF
M5C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M5A0END:
;******* METHOD INDEX 6 - floatAsBits ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$10	; NAME #16
	.BYTE	$00,$11	; DESC #17
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M6A0END-M6A0BGN),<(M6A0END-M6A0BGN)
M6A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$01	; MAX LOCALS 1
	.BYTE	$00,$00,>(M6C0END-M6C0BGN),<(M6C0END-M6C0BGN)
M6C0BGN:
	RTS
M6C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M6A0END:
;******* METHOD INDEX 7 bitsAsFloat ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$12	; NAME #18
	.BYTE	$00,$13	; DESC #19
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M7A0END-M7A0BGN),<(M7A0END-M7A0BGN)
M7A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$01	; MAX LOCALS 1
	.BYTE	$00,$00,>(M7C0END-M7C0BGN),<(M7C0END-M7C0BGN)
M7C0BGN:
	RTS
M7C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M7A0END:
;******* METHOD INDEX 8 - refAsBits ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$14	; NAME #20
	.BYTE	$00,$15	; DESC #21
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M8A0END-M8A0BGN),<(M8A0END-M8A0BGN)
M8A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$01	; MAX LOCALS 1
	.BYTE	$00,$00,>(M8C0END-M8C0BGN),<(M8C0END-M8C0BGN)
M8C0BGN:
	RTS
M8C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M8A0END:
;******* METHOD INDEX 9 - bitsAsRef ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0109
	.BYTE	$00,$16	; NAME #22
	.BYTE	$00,$17	; DESC #23
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M9A0END-M9A0BGN),<(M9A0END-M9A0BGN)
M9A0BGN:
;* CODE:
	.BYTE	$00,$01	; MAX STACK 1
	.BYTE	$00,$01	; MAX LOCALS 1
	.BYTE	$00,$00,>(M9C0END-M9C0BGN),<(M9C0END-M9C0BGN)
M9C0BGN:
	RTS
M9C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M9A0END:
;******* METHOD INDEX 10 - pokeBytes ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0009
	.BYTE	$00,28	; NAME #28
	.BYTE	$00,29	; DESC #29
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M10A0END-M10A0BGN),<(M10A0END-M10A0BGN)
M10A0BGN:
;* CODE:
	.BYTE	$00,$00	; MAX STACK 0
	.BYTE	$00,$04	; MAX LOCALS 4
	.BYTE	$00,$00,>(M10C0END-M10C0BGN),<(M10C0END-M10C0BGN)
M10C0BGN:
	PLA
	STA	$A2
	PLA
	STA	$A3
	PLA		; POP LEN PARAM
	STA	$A4
	PLA
	STA	$A5
	PLA
	PLA
	PLA		; POP OFFSET PARAM
	STA	SRCADDR
	PLA
	STA	SRCADDR+1
	PLA
	PLA
	PLA		; POP BYTE ARRAY
	TAY
	PLA
	STA	$A6
	PLA
	PLA
	LDA	#<(M10C0HMEMCALL-M10C0BGN-1)
	CLC
	ADC	$A0
	TAX
	LDA	#>(M10C0HMEMCALL-M10C0BGN-1)
	ADC	$A1
	PHA
	TXA
	PHA
	TYA
	LDX	$A6
	JMP	($306)	; GET POINTER TO ARRAY
M10C0HMEMCALL:	CLC
	ADC	#$02	; SKIP LENGTH WORD
	BCC	:+
	INX
	CLC
:	ADC	SRCADDR	; ADD TO OFFSET
	STA	SRCADDR
	TXA
	ADC	SRCADDR+1
	STA	SRCADDR+1
	PLA		; POP MEMORY ADDRESS
	STA	DSTADDR
	PLA
	STA	DSTADDR+1
	PLA
	PLA
	LDA	$A3	; PUSH RETURN ADDRESS
	PHA
	LDA	$A2
	PHA
	LDA	$A4	; LOAD LEN
	LDX	$A5
	JMP	($342)	; MEMCPY
M10C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M10A0END:
;******* METHOD INDEX 11 - peekBytes ********
	.BYTE	$01,$09	; ACCESS FLAGS 0x0009
	.BYTE	$00,30	; NAME #30
	.BYTE	$00,29	; DESC #29
	.BYTE	$00,$01	; ATTRIB COUNT 1
;* ATTRIB INDEX 0
	.BYTE	$00,27	; NAME #27
	.BYTE	$00,$00,>(M11A0END-M11A0BGN),<(M11A0END-M11A0BGN)
M11A0BGN:
;* CODE:
	.BYTE	$00,$00	; MAX STACK 0
	.BYTE	$00,$04	; MAX LOCALS 4
	.BYTE	$00,$00,>(M11C0END-M11C0BGN),<(M11C0END-M11C0BGN)
M11C0BGN:
	PLA
	STA	$A2
	PLA
	STA	$A3
	PLA		; POP LEN PARAM
	STA	$A4
	PLA
	STA	$A5
	PLA
	PLA
	PLA		; POP OFFSET PARAM
	STA	DSTADDR
	PLA
	STA	DSTADDR+1
	PLA
	PLA
	PLA		; POP BYTE ARRAY
	TAY
	PLA
	STA	$A6
	PLA
	PLA
	LDA	#<(M11C0HMEMCALL-M10C0BGN-1)
	CLC
	ADC	$A0
	TAX
	LDA	#>(M11C0HMEMCALL-M10C0BGN-1)
	ADC	$A1
	PHA
	TXA
	PHA
	TYA
	LDX	$A6
	JMP	($306)	; GET POINTER TO ARRAY
M11C0HMEMCALL:	CLC
	ADC	#$02	; SKIP LENGTH WORD
	BCC	:+
	INX
	CLC
:	ADC	DSTADDR	; ADD TO OFFSET
	STA	DSTADDR
	TXA
	ADC	DSTADDR+1
	STA	DSTADDR+1
	PLA		; POP MEMORY ADDRESS
	STA	SRCADDR
	PLA
	STA	SRCADDR+1
	PLA
	PLA
	LDA	$A3	; PUSH RETURN ADDRESS
	PHA
	LDA	$A2
	PHA
	LDA	$A4	; LOAD LEN
	LDX	$A5
	JMP	($342)	; MEMCPY
M11C0END:
;* EXCEPTION TABLE
	.BYTE	$00,$00	; COUNT 0
;* CODE ATTRIB
	.BYTE	$00,$00	; ATTRIB COUNT 0
M11A0END:
;*
;* GLOBAL ATTRIBUTES
;*
	.BYTE	$00,$00	; ATTRIB COUNT 0
